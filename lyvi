#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This program is free software. It comes without any warranty, to
# the extent permitted by applicable law. You can redistribute it
# and/or modify it under the terms of the Do What The Fuck You Want
# To Public License, Version 2, as published by Sam Hocevar. See
# http://sam.zoy.org/wtfpl/COPYING for more details.

import os
import sys
import shlex
import locale
import curses
import socket
import textwrap
from time import sleep
from urllib.request import urlopen
from threading import Thread, Lock
from subprocess import Popen, PIPE

import plyr

locale.setlocale(locale.LC_ALL, '')


def parse_config(file):
    settings = {}
    try:
        f = open(file, 'r')
    except IOError:
        pass
    else:
        for l in f.read().splitlines():
            if not l.strip().startswith('#') and '=' in l:
                key, value = l.split('=', 1)
                settings[key.strip()] = value.strip()
            else:
                continue
        f.close()

    return settings


def wrap(text, cols):
    wt = ''
    for l in text.splitlines():
        while len(l) > cols:
            wt += l[:cols - 2] + '->' + '\n '
            l = l[cols - 2:]
        wt += l + '\n '

    return wt[:-2]


def wrapwords(text, cols):
    wt = ''
    for l in text.split('\n'):
        for wl in textwrap.wrap(l, cols):
            wt += wl.strip() + '\n '
        wt += '\n '

    return wt.strip()


def process_socket(command, file):
    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    s.connect(file)
    s.send((command + '\n').encode())
    s.close()


def process_fifo(command, file):
    f = open(file, 'w')
    f.write(command + '\n')
    f.flush()


def get_output(command):
    p = Popen(shlex.split(command), stdout=PIPE, stderr=PIPE)

    return p.communicate()[0].decode().strip()


def running(process):
    if process in get_output('ps -C %s' % process):
        return True
    else:
        return False


def metadata_get(type, artist, title, lang):
    if ((type == 'lyrics' and (artist == 'N/A' or title == 'N/A')) or
        (type == 'artistbio' and artist == 'N/A') or
        (type == 'guitartabs' and (artist == 'N/A' or title == 'N/A'))):
        m = 'Missing tags.'
    else:
        try:
            cache_dir = os.environ['XDG_CACHE_HOME'] + '/lyvi'
        except KeyError:
            cache_dir = os.environ['HOME'] + '/.cache/lyvi'
        if not os.path.exists(cache_dir):
            os.makedirs(cache_dir)

        db = plyr.Database(cache_dir)
        query = plyr.Query(artist=artist, title=title,
                           get_type=type, database=db, language=lang)
        query.useragent = 'lyvi/0.1'
        try:
            m = query.commit()[0].data.decode()
        except IndexError:
            m = 'No %s found.' % type

    return m


def get_and_update(artist, title, data):
    for type in ['lyrics', 'artistbio', 'guitartabs']:
        m = metadata_get(type, artist, title, data['lang'])
        data['lock'].acquire()
        try:
            if data['ui'].artist + data['ui'].title == artist + title:
                setattr(data['ui'], type, m)
                data['ui'].update_content()
        finally:
            data['lock'].release()


class DummyPlayer:
    def status(self):
        if self.run['type'] == 'file':
            runs = os.path.exists(self.run['name'])
        elif self.run['type'] == 'process':
            runs = running(self.run['name'])
        if not runs:
            if self.np['type'] == 'np_file' or self.np['type'] == 'log':
                if os.path.exists(self.np['name']):
                    os.remove(self.np['name'])
            sys.exit()

        if self.np['type'] == 'np_file' or self.np['type'] == 'np_command':
            if self.np['type'] == 'np_file':
                try:
                    f = open(self.np['name'])
                    s = f.read()
                    f.close()
                except IOError:
                    pass
            elif self.np['type'] == 'np_command':
                s = get_output(self.np['name'])

            self.playing = True
            s = s.strip().split('\\')
            if len(s) < 2:
                self.playing = False
            else:
                self.artist = s[0]
                self.title = s[1]
                if len(s) > 2:
                    file = s[2].rsplit('.', 1)[0]
                    if file == self.title:
                        self.title = 'N/A'

        else:
            if self.np['type'] == 'command':
                s = get_output(self.np['name'])
            elif self.np['type'] == 'log':
                f = open(self.np['name'])
                s = f.read().split(self.np['str']['beg'])[-1]
                f.close()
            elif self.np['type'] == 'url':
                p = urlopen(self.np['name'])
                s = p.read().decode()
                p.close()

            if self.np['str']['stopped'] in s:
                self.playing = False
            else:
                self.playing = True
                if self.np['str']['artist_beg'] in s:
                    self.artist = s.split(self.np['str']['artist_beg'])[1] \
                                  .split(self.np['str']['artist_end'])[0]
                else:
                    self.artist = 'N/A'
                if self.np['str']['title_beg'] in s:
                    self.title = s.split(self.np['str']['title_beg'])[1] \
                                 .split(self.np['str']['title_end'])[0]
                else:
                    self.title = 'N/A'

        if self.playing == False:
            self.artist = 'N/A'
            self.title = 'N/A'
        else:
            missing_tag = ['', 'Unknown artist']
            if self.artist in missing_tag:
                self.artist = 'N/A'
            if self.title in missing_tag:
                self.title = 'N/A'

    def command(self, command):
        if command in self.ctl['commands']:
            if self.ctl['type'] == 'socket':
                process_socket(self.ctl['commands'][command], self.ctl['name'])
            elif self.ctl['type'] == 'fifo':
                process_fifo(self.ctl['commands'][command], self.ctl['name'])
            elif self.ctl['type'] == 'command':
                os.system(self.ctl['commands'][command])


class Cmus(DummyPlayer):
    def __init__(self):
        self.run = {'type': 'file',
                    'name': os.environ['HOME'] + '/.cmus/socket'}
        self.np = {'type': 'command',
                   'name': 'cmus-remote -Q',
                   'str': {'artist_beg': 'tag artist ',
                           'artist_end': '\n',
                           'title_beg': 'tag title ',
                           'title_end': '\n',
                           'stopped': 'status stopped'}}
        self.ctl = {'type': 'command',
                    'commands': {'play': 'cmus-remote -p',
                                 'pause': 'cmus-remote -u',
                                 'next': 'cmus-remote -n',
                                 'prev': 'cmus-remote -r',
                                 'stop': 'cmus-remote -s',
                                 'volup': 'cmus-remote -v +5%',
                                 'voldn': 'cmus-remote -v -5%'}}


class Shellfm(DummyPlayer):
    def __init__(self):
        self.run = {'type': 'file',
                    'name': os.environ['HOME'] + '/.shell-fm/session'}
        self.np = {'type': 'np_file',
                   'name': os.environ['HOME'] + '/.shell-fm/nowplaying'}
        self.ctl = {'type': 'socket',
                    'name': os.environ['HOME'] + '/.shell-fm/socket',
                    'commands': {'pause': 'pause',
                                 'next': 'skip',
                                 'stop': 'stop',
                                 'volup': 'volume +5',
                                 'voldn': 'volume -5'}}


class Pianobar(DummyPlayer):
    def __init__(self):
        try:
            config_dir = os.environ['XDG_CONFIG_HOME'] + '/pianobar/'
        except KeyError:
            config_dir = os.environ['HOME'] + '/.config/pianobar/'

        # set default keys
        settings = {'key_pause': 'p',
                    'key_next': 'n',
                    'key_stop': 'q',
                    'key_volup': ')',
                    'key_voldn': '('}
        settings.update(parse_config(config_dir + 'config'))

        self.run = {'type': 'process',
                    'name': 'pianobar'}
        self.np = {'type': 'np_file',
                   'name': config_dir + 'nowplaying'}
        self.ctl = {'type': 'fifo',
                    'name': config_dir + 'ctl',
                    'commands': {'play': settings['key_pause'],
                                 'pause': settings['key_pause'],
                                 'next': settings['key_next'],
                                 'stop': settings['key_stop'],
                                 'volup': settings['key_volup'],
                                 'voldn': settings['key_voldn']}}


class Mpd(DummyPlayer):
    def __init__(self):
        self.run = {'type': 'process',
                    'name': 'mpd'}
        self.np = {'type': 'np_command',
                   'name': 'mpc current -f "%artist%\\%title%"'}
        self.ctl = {'type': 'command',
                    'commands': {'play': 'mpc play > /dev/null',
                                 'pause': 'mpc pause > /dev/null',
                                 'next': 'mpc next > /dev/null',
                                 'prev': 'mpc prev > /dev/null',
                                 'stop': 'mpc stop > /dev/null',
                                 'volup': 'mpc volume +5 > /dev/null',
                                 'voldn': 'mpc volume -5 > /dev/null'}}


class Moc(DummyPlayer):
    def __init__(self):
        self.run = {'type': 'file',
                    'name': os.environ['HOME'] + '/.moc/pid'}
        self.np = {'type': 'command',
                    'name': 'mocp -i',
                    'str': {'artist_beg': 'Artist: ',
                            'artist_end': '\n',
                            'title_beg': 'SongTitle: ',
                            'title_end': '\n',
                            'stopped': 'State: STOP'}}
        self.ctl = {'type': 'command',
                    'commands': {'play': 'mocp -U 2> /dev/null',
                                 'pause': 'mocp -P 2> /dev/null',
                                 'next': 'mocp -f 2> /dev/null',
                                 'prev': 'mocp -r 2> /dev/null',
                                 'stop': 'mocp -s 2> /dev/null',
                                 'volup': 'mocp --volume +5 2> /dev/null',
                                 'voldn': 'mocp --volume -5 2> /dev/null'}}


class Mplayer(DummyPlayer):
    def __init__(self):
        self.run = {'type': 'process',
                    'name': 'mplayer'}
        self.np = {'type': 'log',
                   'name': os.environ['HOME'] + '/.mplayer/log',
                   'str': {'beg': 'AUDIO_ID',
                           'artist_beg': 'VALUE1=',
                           'artist_end': '\n',
                           'title_beg': 'VALUE0=',
                           'title_end': '\n',
                           'stopped': '||||'}}
        self.ctl = {'type': 'fifo',
                    'name': os.environ['HOME'] + '/.mplayer/fifo',
                    'commands': {'play': 'pause',
                                 'pause': 'pause',
                                 'next': 'pt_step 1',
                                 'prev': 'pt_step -1',
                                 'stop': 'stop',
                                 'volup': 'volume +1',
                                 'voldn': 'volume -1'}}


class Vlc(DummyPlayer):
    def __init__(self):
        self.run = {'type': 'file',
                    'name': '/tmp/vlc.sock'}
        self.np = {'type': 'url',
                   'name': 'http://localhost:8080/requests/status.xml',
                   'str': {'artist_beg': 'name=\'artist\'>',
                           'artist_end': '</info>',
                           'title_beg': 'name=\'title\'>',
                           'title_end': '</info>',
                           'stopped': '<state>stopped</state>'}}
        self.ctl = {'type': 'socket',
                    'name': '/tmp/vlc.sock',
                    'commands': {'play': 'pause',
                                 'pause': 'pause',
                                 'next': 'next',
                                 'prev': 'prev',
                                 'stop': 'stop',
                                 'volup': 'volup 1',
                                 'voldn': 'voldown 1'}}


class Audacious(DummyPlayer):
    def __init__(self):
        try:
            config_dir = os.environ['XDG_CONFIG_HOME'] + '/audacious/'
        except KeyError:
            config_dir = os.environ['HOME'] + '/.config/audacious/'

        self.run = {'type': 'file',
                    'name': config_dir + 'lock'}
        self.np = {'type': 'np_file',
                   'name': config_dir + 'nowplaying'}
        self.ctl = {'type': 'command',
                    'commands': {'play': 'audtool --playback-playpause',
                                 'pause': 'audtool --playback-playpause',
                                 'next': 'audtool --playlist-advance',
                                 'prev': 'audtool --playlist-reverse',
                                 'stop': 'audtool --playback-stop',
                                 'volup': 'audtool --set-volume +5',
                                 'voldn': 'audtool --set-volume -5'}}


class Deadbeef(DummyPlayer):
    def __init__(self):
        self.run = {'type': 'process',
                    'name': 'deadbeef-main'}
        self.np = {'type': 'np_command',
                   'name': 'deadbeef --nowplaying "%a%\\%t%\\%f%"'}
        self.ctl = {'type': 'command',
                    'commands': {'play': 'deadbeef --play 2> /dev/null',
                                 'pause': 'deadbeef --toggle-pause \
                                           2> /dev/null',
                                 'next': 'deadbeef --next 2> /dev/null',
                                 'prev': 'deadbeef --prev 2> /dev/null',
                                 'stop': 'deadbeef --stop 2> /dev/null'}}


class Qmmp(DummyPlayer):
    def __init__(self):
        self.run = {'type': 'file',
                    'name': '/tmp/qmmp.sock.1000'}
        self.np = {'type': 'command',
                   'name': 'qmmp --status',
                   'str': {'artist_beg': 'ARTIST = ',
                           'artist_end': '\n',
                           'title_beg': 'TITLE = ',
                           'title_end': '\n',
                           'stopped': '[stopped]'}}
        self.ctl = {'type': 'command',
                    'commands': {'play': 'qmmp -t',
                                 'pause': 'qmmp -t',
                                 'next': 'qmmp --next',
                                 'prev': 'qmmp --previous',
                                 'stop': 'qmmp -s',
                                 'volup': 'qmmp --volume-inc',
                                 'voldn': 'qmmp --volume-dec'}}


class Ui:
    def __init__(self, data):
        self.screen = data['screen']
        self.settings = data['settings']
        self.player = data['player']
        self.quit = False
        self.artist = ''
        curses.curs_set(0)

        # init colors
        curses.use_default_colors()
        curses.init_pair(1, int(self.settings['color_title']), -1)
        curses.init_pair(2, int(self.settings['color_text']), -1)
        curses.init_pair(3, int(self.settings['color_status']), -1)

    def update_content(self):
        self.pos_y = 0
        self.y, self.x = self.screen.getmaxyx()
        if self.settings['view'] == 'lyrics':
            self.header = self.artist + ' - ' + self.title
            self.text = self.lyrics
            text_wrap = wrap(self.text, self.x - 2)
        elif self.settings['view'] == 'artistbio':
            self.header = self.artist
            self.text = self.artistbio
            text_wrap = wrapwords(self.text, self.x - 2)
        elif self.settings['view'] == 'guitartabs':
            self.header = self.artist + ' - ' + self.title
            self.text = self.guitartabs
            text_wrap = wrap(self.text, self.x - 2)
        header_wrap = wrap(self.header, self.x - 2)
        self.pad_lines = len(header_wrap.splitlines()) + \
                         len(text_wrap.splitlines()) + 1

        # main window
        self.pad = curses.newpad(self.pad_lines + self.y, self.x)
        self.pad.addstr(0, 1, header_wrap,
                        curses.color_pair(1) | curses.A_BOLD)
        self.pad.addstr(len(header_wrap.splitlines()) + 1, 1, text_wrap,
                        curses.color_pair(2))

        # statusbar
        self.statusbar = curses.newpad(1, self.x)

        self.refresh()

    def refresh(self):
        self.pad.noutrefresh(self.pos_y, 0, 0, 0, self.y - 2, self.x)

        self.statusbar.erase()
        if self.pad_lines <= self.y - 1:
            pos_perc = 'All'
        elif self.pos_y == 0:
            pos_perc = 'Top'
        elif self.pos_y > self.pad_lines - self.y:
            pos_perc = 'Bot'
        else:
            pos_perc = str(int((100 / float(self.pad_lines - self.y)) \
                               * self.pos_y - 1)) + '%'
        self.statusbar.addstr(0, self.x - len(pos_perc) - 1, pos_perc,
                              curses.color_pair(3))
        self.statusbar.addstr(0, self.x - len(self.settings['view']) - 10,
                              self.settings['view'], curses.color_pair(3))
        self.statusbar.noutrefresh(0, 0, self.y - 1, 0, self.y, self.x)

        curses.doupdate()

    def control(self):
        commands = {ord(self.settings['key_play']): 'play',
                    ord(self.settings['key_pause']): 'pause',
                    ord(self.settings['key_next']): 'next',
                    ord(self.settings['key_prev']): 'prev',
                    ord(self.settings['key_stop']): 'stop',
                    ord(self.settings['key_volup']): 'volup',
                    ord(self.settings['key_voldn']): 'voldn'}
        views = ['lyrics', 'artistbio', 'guitartabs']
        while True:
            key = self.screen.getch()

            if key == ord(self.settings['key_quit']):
                self.quit = True

            elif key == curses.KEY_RESIZE:
                self.update_content()

            elif key == ord(self.settings['key_toggle']):
                i = views.index(self.settings['view']) + 1
                if i >= len(views):
                    i = 0
                self.settings['view'] = views[i]
                self.update_content()

            elif key in commands:
                self.player.command(commands[key])

            else:
                if key == curses.KEY_DOWN or key == ord('j'):
                    if self.pos_y < self.pad_lines - self.y + 1:
                        self.pos_y += 1

                elif key == curses.KEY_NPAGE or key == curses.KEY_RIGHT:
                    if self.pos_y < self.pad_lines - self.y + 1:
                        self.pos_y += self.y - 1

                elif key == curses.KEY_END or key == ord('G'):
                    if self.pos_y < self.pad_lines - self.y + 1:
                        self.pos_y = self.pad_lines - self.y + 1

                elif key == curses.KEY_UP or key == ord('k'):
                    if self.pos_y > 0:
                        self.pos_y -= 1

                elif key == curses.KEY_PPAGE or key == curses.KEY_LEFT:
                    if self.pos_y - self.y > 0:
                        self.pos_y -= self.y - 1
                    else:
                        self.pos_y = 0

                elif key == curses.KEY_HOME or key == ord('g'):
                    self.pos_y = 0

                self.refresh()


def main(stdscr):
    try:
        config_file = os.environ['XDG_CONFIG_HOME'] + '/lyvi/rc'
    except KeyError:
        config_file = os.environ['HOME'] + '/.config/lyvi/rc'

    # default settings
    settings = {'lang': 'en',
                'view': 'lyrics',
                'key_quit': 'q',
                'key_toggle': 'a',
                'key_play': 'x',
                'key_pause': 'c',
                'key_next': 'b',
                'key_prev': 'z',
                'key_stop': 'v',
                'key_volup': '=',
                'key_voldn': '-',
                'color_title': 7,
                'color_text': -1,
                'color_status': -1}

    settings.update(parse_config(config_file))

    u = Ui({'screen': stdscr, 'player': p, 'settings': settings})

    ui_control = Thread(target=u.control)
    ui_control.daemon = True
    ui_control.start()

    lock = Lock()
    data = {'ui': u, 'lock': lock, 'lang': settings['lang']}

    while True:
        if u.quit == True:
            break

        p.status()

        if p.playing == True:
            if p.artist != u.artist or p.title != u.title:
                lock.acquire()
                try:
                    u.artist = p.artist
                    u.title = p.title
                    u.lyrics = 'Downloading lyrics...'
                    u.artistbio = 'Downloading artist info...'
                    u.guitartabs = 'Downloading guitar tab...'
                    u.update_content()
                finally:
                    lock.release()

                worker = Thread(target=get_and_update,
                                args=(p.artist, p.title, data))
                worker.daemon = True
                worker.start()
        else:
            u.artist = p.artist
            u.title = p.title
            u.lyrics = 'Not playing'
            u.artistbio = 'Not playing'
            u.guitartabs = 'Not playing'
            u.update_content()

        sleep(1)


if __name__ == '__main__':
    if os.path.exists(os.environ['HOME'] + '/.cmus/socket'):
        p = Cmus()
    elif os.path.exists(os.environ['HOME'] + '/.shell-fm/session'):
        p = Shellfm()
    elif running('pianobar'):
        p = Pianobar()
    elif running('mpd'):
        p = Mpd()
    elif os.path.exists(os.environ['HOME'] + '/.moc/pid'):
        p = Moc()
    elif running('mplayer'):
        p = Mplayer()
    elif os.path.exists('/tmp/vlc.sock'):
        p = Vlc()
    elif running('audacious'):
        p = Audacious()
    elif running('deadbeef-main'):
        p = Deadbeef()
    elif os.path.exists('/tmp/qmmp.sock.1000'):
        p = Qmmp()
    else:
        print('No supported player found.')
        sys.exit()

    if len(sys.argv) > 1:
        p.command(sys.argv[1])
    else:
        curses.wrapper(main)
